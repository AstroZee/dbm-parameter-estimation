# -*- coding: utf-8 -*-
"""w_gamma_estimation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oqJYUXz3J5swnP-8WFUigc5rYwKmnyIg
"""

def get_w_gamma_estimates(t, r0, v0, r_at_t, v_at_t):
    """
    Evaluates estimates of solar wind speed (w) and drag parameter (gamma)
    The function goes through a range of initial conditions of w and gamma to estimate true w and gamma, and returns the median of these estimates

    Parameters:
    t: time that passed since measuring v0 at r0 in seconds
    r0: Initial distance of the CME from the Sun in km
    v0: Initial velocity of the CME from the Sun meansured at r0 in km/s
    r_at_t: mesurement of distance of CME at the iteration step in km
    v_at_t: Measurement of speed of CME at the iteration step in km/s

    Returns:
    Estimate of w in km/s, estimate of gamma in 1/km
    """
    k_step = 25  # Number of iterations for numerical solution

    w_est_list = list() #To store the obtained w estimates
    gamma_est_list = list() #To store the obtained gamma estimates

    # Arrays of initial guesses
    w_range = np.arange(250, 1001, 10) #The range of initial w guesses
    gamma_range = np.arange(0.1, 1.05, 0.01) *1e-7 #The range of initial gamma guesses

    for GAMMA in gamma_range:
        for W in w_range:
            w_0 = W #Set the initial guess for w
            gamma_0 = GAMMA  #Set the initial guess for gamma

            #Run k steps
            for k in range(k_step):
                if k > 0:
                    w_0 = w_est
                    gamma_0 = gamma_est

                if v0 >= w_0:
                    r_0 = (1/gamma_0) * np.log(1 + gamma_0 * (v0 - w_0) * t) + w_0 * t + r0
                    v_0 = (v0 - w_0) / (1 + gamma_0 * (v0 - w_0) * t) + w_0

                    if (1 + gamma_0 * (v0 - w_0) * t) <= 0:
                        break

                else:
                    r_0 = -(1/gamma_0) * np.log(1 - gamma_0 * (v0 - w_0) * t) + w_0 * t + r0
                    v_0 = (v0 - w_0) / (1 - gamma_0 * (v0 - w_0) * t) + w_0

                    if (1 - gamma_0 * (v0 - w_0) * t) <= 0:
                        break


                # Partial derivatives for the first order Taylor expansion
                if v0 >= w_0:
                    rgamma = - np.log(1 + gamma_0 * (v0 - w_0) * t) / (gamma_0**2) + \
                                (v0 - w_0) * t / (gamma_0 * (1 + gamma_0 * (v0 - w_0) * t))
                    rw = -t / (1 + gamma_0 * (v0 - w_0) * t) + t
                    vgamma = (-(v0 - w_0)**2 * t) / (1 + gamma_0 * (v0 - w_0) * t)**2
                    vw = (-(1 + gamma_0 * (v0 - w_0) * t) + (v0 - w_0) * t * gamma_0) / \
                            (1 + gamma_0 * (v0 - w_0) * t)**2 + 1

                else:
                    rgamma = np.log(1 - gamma_0 * (v0 - w_0) * t) / (gamma_0**2) + \
                                (v0 - w_0) * t / (gamma_0 * (1 - gamma_0 * (v0 - w_0) * t))
                    rw = -t / (1 - gamma_0 * (v0 - w_0) * t) + t
                    vgamma = ((v0 - w_0)**2 * t) / (1 - gamma_0 * (v0 - w_0) * t)**2
                    vw = (-(1 - gamma_0 * (v0 - w_0) * t) - (v0 - w_0) * t * gamma_0) / \
                            (1 - gamma_0 * (v0 - w_0) * t)**2 + 1

                # w and gamma estimates update
                w_est = ((r_at_t - r_0) * vgamma - (v_at_t - v_0) * rgamma) / \
                            (rw * vgamma - vw * rgamma) + w_0

                gamma_est = ((r_at_t - r_0) * vw - (v_at_t - v_0) * rw) / \
                                (-rw * vgamma + vw * rgamma) + gamma_0

                #Solution acceptance checks

                #Negative w encountered
                if w_est <= 0:
                    break

                #Negative gamma encountered
                if gamma_est < 0:
                    break

                #Denominator equals 0
                if rw * vgamma - vw * rgamma == 0:
                    break

                #Denominator equals 0
                if -rw * vgamma + vw * rgamma == 0:
                    break

                #Physical limits check
                if w_est < 250 or w_est > 800 or gamma_est < 0.1e-7 or gamma_est > 1e-7:
                    flag = True

            #Comlpleted k iterations
            if k == k_step - 1 and not flag:
                w_est_list.append(w_est)
                gamma_est_list.append(gamma_est)

    #Obtain median of all stored estimates
    w_est_median = np.median(w_est_list)
    gamma_est_median = np.median(gamma_est_list)

    return w_est_median, gamma_est_median